%{
#include "asm.h"
#include <assert.h>
#include "panic.h"
#include "regmap.h"
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include "symtab.h"
#include "tree.h"

struct CodeGenContext {
    char *fn_name;
    bool regs[REG_COUNT];
    struct regmap *var_to_reg;
    int params_count;
};

static struct CodeGenContext ctx;

enum Register reg() {
    for (int i = 0; i < REG_COUNT; ++i) {
        if (!ctx.regs[i]) {
            ctx.regs[i] = true;
            return i;
        }
    }
    panic("out of registers");
}

void free_reg(enum Register r) {
    ctx.regs[r] = false;
}

void flip(struct Tree *node) {
    struct Tree *tmp = node->kids[0];
    node->kids[0] = node->kids[1];
    node->kids[1] = tmp;
}

//
// RETURN
//

void return__RETURN(struct Tree *node) {
    node->reg = LEFT_CHILD(node)->reg;
    asm_move_reg_reg(node->reg, RAX);
    asm_return();
    free_reg(node->reg);
}

void return__RETURN_numreg(struct Tree *node) {
    asm_tag_number(LEFT_CHILD(node)->reg);
    return__RETURN(node);
}

void return__RETURN_lstreg(struct Tree *node) {
    asm_tag_list(LEFT_CHILD(node)->reg);
    return__RETURN(node);
}

//
// NOT, HEAD, TAIL
//

void numreg__NOT_numreg(struct Tree *node) {
    node->reg = LEFT_CHILD(node)->reg;
    asm_xor_immediate(1, node->reg);
}

void const__NOT_const(struct Tree *node) {
    node->num = LEFT_CHILD(node)->num ^ 1;
}

void numreg__HEAD_lstreg(struct Tree *node) {
    enum Register target = LEFT_CHILD(node)->reg;
    asm_move_head_reg(target);
    node->reg = target;
}

void numreg__TAIL_lstreg(struct Tree *node) {
    enum Register target = LEFT_CHILD(node)->reg;
    asm_move_tail_reg(target);
    node->reg = target;
}

//
// ISLIST
//

void numreg__ISLIST_reg(struct Tree *node) {
    node->reg = LEFT_CHILD(node)->reg;
    asm_and_immediate(1, node->reg);
}

void const__ISLIST_const(struct Tree *node) {
    node->num = 0;
}

void numreg__ISLIST_lstreg(struct Tree *node) {
    asm_immediate(1, node->reg);
}

void numreg__ISLIST_numreg(struct Tree *node) {
    asm_immediate(0, node->reg);
}

//
// ADD, MUL, OR
//
void numreg__BIN_numreg_numreg(struct Tree *node, enum Type type) {
    enum Register source = LEFT_CHILD(node)->reg;
    enum Register target = RIGHT_CHILD(node)->reg;
    switch(type) {
        case TREE_ADD: asm_add(source, target); break;
        case TREE_MUL: asm_mul(source, target); break;
        case TREE_OR:  asm_or(source, target); break;
        case TREE_SUB:
            source = target;
            target = LEFT_CHILD(node)->reg;
            asm_sub(source, target);
            break;
        case TREE_GE:  asm_le(source, target);  break; // TODO check
        default: panic("invalid type %d", type);
    }
    node->reg = target;
    free_reg(source);
}

void numreg__BIN_const_numreg(struct Tree *node, enum Type type) {
    enum Register target = RIGHT_CHILD(node)->reg;
    switch(type) {
        case TREE_ADD: asm_add_immediate(LEFT_CHILD(node)->num, target); break;
        case TREE_MUL: asm_mul_immediate(LEFT_CHILD(node)->num, target); break;
        case TREE_OR:  asm_or_immediate(LEFT_CHILD(node)->num, target);  break;
        case TREE_SUB:
            asm_neg(target);
            asm_add_immediate(LEFT_CHILD(node)->num, target);
            break;
        case TREE_GE: asm_le_immediate(LEFT_CHILD(node)->num, target);  break;
        default: panic("invalid type %d", type);
    }
    node->reg = target;
}

void numreg__BIN_numreg_const(struct Tree *node, enum Type type) {
    switch(type) {
        case TREE_GE:
            node->reg = LEFT_CHILD(node)->reg;
            asm_ge_immediate(RIGHT_CHILD(node)->num, node->reg);
            break;
        case TREE_SUB:
            node->reg = LEFT_CHILD(node)->reg;
            asm_sub_immediate(RIGHT_CHILD(node)->num, node->reg);
            break;
        default:
            flip(node);
            numreg__BIN_const_numreg(node, type);
    }
}

void numreg__BIN_const_const(struct Tree *node, enum Type type) {
    unsigned long long ln = LEFT_CHILD(node)->num;
    unsigned long long rn = RIGHT_CHILD(node)->num;
    switch(type) {
        case TREE_ADD: node->num = ln + rn; break;
        case TREE_MUL: node->num = ln * rn; break;
        case TREE_OR:  node->num = ln | rn; break;
        case TREE_SUB: node->num = ln - rn; break;
        case TREE_GE:  node->num = ln >= rn; break;
        default: panic("invalid type %d", type);
    }
}

//
// EQ
//

void numreg__EQ_tagreg_tagreg(struct Tree *node) {
    enum Register source = LEFT_CHILD(node)->reg;
    enum Register target = RIGHT_CHILD(node)->reg;

    asm_eq(source, target);

    node->reg = target;
    free_reg(source);
}

void numreg__EQ_const_tagreg(struct Tree *node) {
    enum Register target = RIGHT_CHILD(node)->reg;
    unsigned long long value = LEFT_CHILD(node)->num << 1;
    asm_eq_immediate(value, target);
    node->reg = target;
}

void numreg__EQ_tagreg_const(struct Tree *node) {
    flip(node);
    numreg__EQ_const_tagreg(node);
}

void numreg__EQ_const_const(struct Tree *node) {
    node->num = LEFT_CHILD(node)->num == RIGHT_CHILD(node)->num;
}

//
// CONS
//

void numreg__CONS_tagreg_tagreg(struct Tree *node) {
    enum Register source = LEFT_CHILD(node)->reg;
    enum Register target = RIGHT_CHILD(node)->reg;

    asm_cons(source, target);

    node->reg = target;
    free_reg(source);
}

void numreg__CONS_const_tagreg(struct Tree *node) {
    enum Register target = RIGHT_CHILD(node)->reg;
    unsigned long long value = LEFT_CHILD(node)->num << 1;
    asm_cons_imm_reg(value, target);
    node->reg = target;
}

void numreg__CONS_tagreg_const(struct Tree *node) {
    enum Register target = LEFT_CHILD(node)->reg;
    unsigned long long value = RIGHT_CHILD(node)->num << 1;
    asm_cons_reg_imm(value, target);
    node->reg = target;
}

void numreg__CONS_const_const(struct Tree *node) {
    // TODO constant lists?
    enum Register target = reg();
    unsigned long long v1 = LEFT_CHILD(node)->num << 1;
    unsigned long long v2 = RIGHT_CHILD(node)->num << 1;
    asm_cons_imm_imm(v1, v2, target);
    node->reg = target;
}

//
// VAR
//

void reg__VAR(struct Tree *node) {
    struct RegInfo reg_info = regmap_lookup(ctx.var_to_reg, node->id);
    node->reg = reg();
    asm_move_reg_reg(reg_info.reg, node->reg);
}

//
// raisesig
//

void raisesig_and_set_reg(struct Tree *node) {
    // TODO only emit raisesig and no other instructions
    struct Tree *left = LEFT_CHILD(node);
    enum Register left_reg = left ? left->reg : REGISTER_NONE;

    struct Tree *right = RIGHT_CHILD(node);
    enum Register right_reg = right ? right->reg : REGISTER_NONE;

    enum Register r = left_reg;
    if (r == REGISTER_NONE) {
        r = right_reg;
    } else if (right_reg != REGISTER_NONE) {
        free_reg(right_reg);
    }
    if (r == REGISTER_NONE)
        r = reg();

    node->reg = r;
    asm_raisesig();
}


/* symbols below must also be defined
   definition in tree.h!!!
*/
%}
%term CONST=1
%term VAR=2
%term ADD=3
%term SUB=4
%term MUL=5
%term CONS=6
%term GE=7
%term EQ=8
%term OR=9
%term NOT=10
%term ISLIST=11
%term HEAD=12
%term TAIL=13
%term RETURN=14
%term EXPR=15
%term NIL=16
%term DECL=17
%term ASSIGN=18


%start stat
%%
stat: return                      # 0    #
return: RETURN(reg)               # 1    # return__RETURN(bnode);
return: RETURN(numreg)            # 1    # return__RETURN_numreg(bnode);
return: RETURN(lstreg)            # 1    # return__RETURN_lstreg(bnode);
numreg: NOT(numreg)               # 1    # numreg__NOT_numreg(bnode);
const:  NOT(const)                # 0    # const__NOT_const(bnode);
numreg: NOT(errreg)               # 1000 # raisesig_and_set_reg(bnode);
reg:    HEAD(lstreg)              # 1    # numreg__HEAD_lstreg(bnode);
reg:    HEAD(errreg)              # 1000 # raisesig_and_set_reg(bnode);
reg:    TAIL(lstreg)              # 1    # numreg__TAIL_lstreg(bnode);
reg:    TAIL(errreg)              # 1000 # raisesig_and_set_reg(bnode);
numreg: ISLIST(reg)               # 1    # numreg__ISLIST_reg(bnode);
const:  ISLIST(const)             # 0    # const__ISLIST_const(bnode);
numreg: ISLIST(lstreg)            # 1    # numreg__ISLIST_lstreg(bnode);
numreg: ISLIST(numreg)            # 1    # numreg__ISLIST_numreg(bnode);
numreg: ADD(numreg, numreg)       # 1    # numreg__BIN_numreg_numreg(bnode, TREE_ADD);
numreg: ADD(const, numreg)        # 1    # numreg__BIN_const_numreg(bnode, TREE_ADD);
numreg: ADD(numreg, const)        # 1    # numreg__BIN_numreg_const(bnode, TREE_ADD);
const:  ADD(const, const)         # 0    # numreg__BIN_const_const(bnode, TREE_ADD);
numreg: ADD(errreg, errreg)       # 1000 # raisesig_and_set_reg(bnode);
numreg: MUL(numreg, numreg)       # 1    # numreg__BIN_numreg_numreg(bnode, TREE_MUL);
numreg: MUL(const, numreg)        # 1    # numreg__BIN_const_numreg(bnode, TREE_MUL);
numreg: MUL(numreg, const)        # 1    # numreg__BIN_numreg_const(bnode, TREE_MUL);
const:  MUL(const, const)         # 0    # numreg__BIN_const_const(bnode, TREE_MUL);
numreg: MUL(errreg, errreg)       # 1000 # raisesig_and_set_reg(bnode);
numreg: OR(numreg, numreg)        # 1    # numreg__BIN_numreg_numreg(bnode, TREE_OR);
numreg: OR(const, numreg)         # 1    # numreg__BIN_const_numreg(bnode, TREE_OR);
numreg: OR(numreg, const)         # 1    # numreg__BIN_numreg_const(bnode, TREE_OR);
const:  OR(const, const)          # 0    # numreg__BIN_const_const(bnode, TREE_OR);
numreg: OR(errreg, errreg)        # 1000 # raisesig_and_set_reg(bnode);
numreg: SUB(numreg, numreg)       # 1    # numreg__BIN_numreg_numreg(bnode, TREE_SUB);
numreg: SUB(const, numreg)        # 1    # numreg__BIN_const_numreg(bnode, TREE_SUB);
numreg: SUB(numreg, const)        # 1    # numreg__BIN_numreg_const(bnode, TREE_SUB);
const:  SUB(const, const)         # 0    # numreg__BIN_const_const(bnode, TREE_SUB);
numreg: SUB(errreg, errreg)       # 1000 # raisesig_and_set_reg(bnode);
numreg: GE(numreg, numreg)        # 1    # numreg__BIN_numreg_numreg(bnode, TREE_GE);
numreg: GE(const, numreg)         # 1    # numreg__BIN_const_numreg(bnode, TREE_GE);
numreg: GE(numreg, const)         # 1    # numreg__BIN_numreg_const(bnode, TREE_GE);
const:  GE(const, const)          # 0    # numreg__BIN_const_const(bnode, TREE_GE);
numreg: GE(errreg, errreg)        # 1000 # raisesig_and_set_reg(bnode);
numreg: EQ(tagreg, tagreg)        # 1    # numreg__EQ_tagreg_tagreg(bnode);
numreg: EQ(const, tagreg)         # 1    # numreg__EQ_const_tagreg(bnode);
numreg: EQ(tagreg, const)         # 1    # numreg__EQ_tagreg_const(bnode);
const:  EQ(const, const)          # 0    # numreg__EQ_const_const(bnode);
lstreg: CONS(tagreg, tagreg)      # 1    # numreg__CONS_tagreg_tagreg(bnode);
lstreg: CONS(const, tagreg)       # 1    # numreg__CONS_const_tagreg(bnode);
lstreg: CONS(tagreg, const)       # 1    # numreg__CONS_tagreg_const(bnode);
lstreg: CONS(const, const)        # 0    # numreg__CONS_const_const(bnode);
tagreg: reg                       # 0    #
tagreg: numreg                    # 1    # asm_tag_number(bnode->reg);
tagreg: lstreg                    # 1    # asm_tag_list(bnode->reg);
errreg: reg                       # 1000 #
errreg: numreg                    # 1000 #
errreg: lstreg                    # 1000 #
numreg: reg                       # 1    # asm_untag_number(bnode->reg);
lstreg: reg                       # 1    # asm_untag_list(bnode->reg);
const: CONST                      # 0    #
reg: CONST                        # 1    # asm_immediate(bnode->num<<1, (bnode->reg=reg()));
reg: const                        # 1    # asm_immediate(bnode->num<<1, (bnode->reg=reg()));
reg: VAR                          # 1    # reg__VAR(bnode);
%%

void burm_reduce(NODEPTR_TYPE bnode, int goalnt);

void addParam(char *name) {
    enum Register r = reg();
    regmap_insert(ctx.var_to_reg, name, (struct RegInfo) { .reg = r });
    ++ctx.params_count;
}

void codegen_begin_function(char *fn_name, struct Symtab *params) {
    ctx = (struct CodeGenContext) {
        .fn_name = fn_name,
        .var_to_reg = regmap_new(),
        .params_count = 0,
    };
    symtab_foreach_variable(params, addParam);
    if (ctx.params_count > 6) {
        panic("too many params");
    }

    printf("\t.extern raisesig\n", fn_name);

    printf("\t.global %s\n", fn_name);
    printf("\t.type %s, @function\n", fn_name);
    printf("%s:\n", fn_name);
    printf("\t.cfi_startproc\n");
}

void codegen_end_function() {
    printf("\t.cfi_endproc\n");
    printf("\t.size %s, .-%s\n", ctx.fn_name, ctx.fn_name);
}

void codegen_empty_function() {
    printf("\tret\n");
}

void codegen_statement(NODEPTR_TYPE root) {
    if(burm_label(root)) {
        burm_reduce(root, 1);
    } else {
        panic("unable to burm_label");
    }
}

