%{
#include "asm.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include "tree.h"
#include "regmap.h"
#include <stdbool.h>
#include "symtab.h"

struct CodeGenContext {
    char *fn_name;
    bool regs[REG_COUNT];
    struct regmap *var_to_reg;
    int params_count;
};

static struct CodeGenContext ctx;

enum Register reg() {
    for (int i = 0; i < REG_COUNT; ++i) {
        if (!ctx.regs[i]) {
            ctx.regs[i] = true;
            return i;
        }
    }
    printf("out of registers\n");
    exit(1);
}

void free_reg(enum Register r) {
    ctx.regs[r] = false;
}

void flip(struct Tree *node) {
    struct Tree *tmp = node->kids[0];
    node->kids[0] = node->kids[1];
    node->kids[1] = tmp;
}

//
// RETURN
//

void return__RETURN(struct Tree *node) {
    node->reg = LEFT_CHILD(node)->reg;
    asm_move_reg_reg(node->reg, RAX);
    asm_return();
}

void return__RETURN_numreg(struct Tree *node) {
    asm_tag_number(LEFT_CHILD(node)->reg);
    return__RETURN(node);
}

void return__RETURN_lstreg(struct Tree *node) {
    asm_tag_list(LEFT_CHILD(node)->reg);
    return__RETURN(node);
}

//
// NOT
//

void numreg__NOT_numreg(struct Tree *node) {
    node->reg = LEFT_CHILD(node)->reg;
    asm_xor1(node->reg);
}

//
// ADD
//

void numreg__ADD_numreg_numreg(struct Tree *node) {
    enum Register source = LEFT_CHILD(node)->reg;
    enum Register target = RIGHT_CHILD(node)->reg;
    asm_add(source, target);
    node->reg = target;
    free_reg(source);
}

void numreg__ADD_const_numreg(struct Tree *node) {
    enum Register target = RIGHT_CHILD(node)->reg;
    asm_add_immediate(LEFT_CHILD(node)->num, target);
    node->reg = target;
}

void numreg__ADD_numreg_const(struct Tree *node) {
    flip(node);
    numreg__ADD_const_numreg(node);
}

void numreg__ADD_const_const(struct Tree *node) {
    node->num = LEFT_CHILD(node)->num + RIGHT_CHILD(node)->num;
}

//
// MUL
//

void numreg__MUL_numreg_numreg(struct Tree *node) {
    enum Register source = LEFT_CHILD(node)->reg;
    enum Register target = RIGHT_CHILD(node)->reg;
    asm_mul(source, target);
    node->reg = target;
    free_reg(source);
}

void numreg__MUL_const_numreg(struct Tree *node) {
    enum Register target = RIGHT_CHILD(node)->reg;
    asm_mul_immediate(LEFT_CHILD(node)->num, target);
    node->reg = target;
}

void numreg__MUL_numreg_const(struct Tree *node) {
    flip(node);
    numreg__MUL_const_numreg(node);
}

void numreg__MUL_const_const(struct Tree *node) {
    node->num = LEFT_CHILD(node)->num * RIGHT_CHILD(node)->num;
}

//
// OR
//
// TODO OR could also operate on tagged values (AND and MUL too)

void numreg__OR_numreg_numreg(struct Tree *node) {
    enum Register source = LEFT_CHILD(node)->reg;
    enum Register target = RIGHT_CHILD(node)->reg;
    asm_or(source, target);
    node->reg = target;
    free_reg(source);
}

void numreg__OR_const_numreg(struct Tree *node) {
    enum Register target = RIGHT_CHILD(node)->reg;
    asm_or_immediate(LEFT_CHILD(node)->num, target);
    node->reg = target;
}

void numreg__OR_numreg_const(struct Tree *node) {
    flip(node);
    numreg__OR_const_numreg(node);
}

void numreg__OR_const_const(struct Tree *node) {
    node->num = LEFT_CHILD(node)->num | RIGHT_CHILD(node)->num;
}

//
// VAR
//

void reg__VAR(struct Tree *node) {
    struct RegInfo reg_info = regmap_lookup(ctx.var_to_reg, node->id);
    node->reg = reg();
    asm_move_reg_reg(reg_info.reg, node->reg);
}

/* symbols below must also be defined
   definition in tree.h!!!
*/
%}
%term CONST=1
%term VAR=2
%term ADD=3
%term SUB=4
%term MUL=5
%term CONS=6
%term NOT_LESS=7
%term EQUAL=8
%term OR=9
%term NOT=10
%term ISLIST=11
%term HEAD=12
%term TAIL=13
%term STATS=14
%term RETURN=15
%term EXPR=16
%term NIL=17

%start stats
%%
stats: nil                        # 0    # printf("\tret\n");
stats: STATS(return,nil)          # 1    #
return: RETURN(reg)               # 1    # return__RETURN(bnode);
return: RETURN(numreg)            # 1    # return__RETURN_numreg(bnode);
return: RETURN(lstreg)            # 1    # return__RETURN_lstreg(bnode);
numreg: NOT(numreg)               # 1    # numreg__NOT_numreg(bnode);
numreg: NOT(errreg)               # 1000 # asm_raisesig();
numreg: ADD(numreg, numreg)       # 1    # numreg__ADD_numreg_numreg(bnode);
numreg: ADD(const, numreg)        # 1    # numreg__ADD_const_numreg(bnode);
numreg: ADD(numreg, const)        # 1    # numreg__ADD_numreg_const(bnode);
const:  ADD(const, const)         # 0    # numreg__ADD_const_const(bnode);
numreg: ADD(errreg, errreg)       # 1000 # asm_raisesig();
numreg: MUL(numreg, numreg)       # 1    # numreg__MUL_numreg_numreg(bnode);
numreg: MUL(const, numreg)        # 1    # numreg__MUL_const_numreg(bnode);
numreg: MUL(numreg, const)        # 1    # numreg__MUL_numreg_const(bnode);
const:  MUL(const, const)         # 0    # numreg__MUL_const_const(bnode);
numreg: MUL(errreg, errreg)       # 1000 # asm_raisesig();
numreg: OR(numreg, numreg)        # 1    # numreg__OR_numreg_numreg(bnode);
numreg: OR(const, numreg)         # 1    # numreg__OR_const_numreg(bnode);
numreg: OR(numreg, const)         # 1    # numreg__OR_numreg_const(bnode);
const:  OR(const, const)          # 0    # numreg__OR_const_const(bnode);
numreg: OR(errreg, errreg)        # 1000 # asm_raisesig();
errreg: reg                       # 1000 #
errreg: numreg                    # 1000 #
errreg: lstreg                    # 1000 #
numreg: reg                       # 1    # asm_untag_number(bnode->reg);
lstreg: reg                       # 1    # asm_untag_list(bnode->reg);
const: CONST                      # 0    #
reg: CONST                        # 1    # asm_immediate(bnode->num, (bnode->reg = reg()));
reg: const                        # 1    # asm_immediate(bnode->num, (bnode->reg = reg()));
reg: VAR                          # 1    # reg__VAR(bnode);
nil: NIL                          # 0    # ;
%%

void burm_reduce(NODEPTR_TYPE bnode, int goalnt);

void addParam(char *name) {
    enum Register r = reg();
    regmap_insert(ctx.var_to_reg, name, (struct RegInfo) { .reg = r });
    ++ctx.params_count;
}

void invoke_burm(NODEPTR_TYPE root, char *fn_name, struct Symtab *params) {
    ctx = (struct CodeGenContext) {
        .fn_name = fn_name,
        .var_to_reg = regmap_new(),
        .params_count = 0,
    };
    symtab_foreach_variable(params, addParam);
    if (ctx.params_count > 6) {
        printf("too many params\n");
        exit(32);
    }
    if(burm_label(root)) {
        printf("\t.extern raisesig\n", fn_name);

        printf("\t.global %s\n", fn_name);
        printf("\t.type %s, @function\n", fn_name);
        printf("%s:\n", fn_name);
        printf("\t.cfi_startproc\n");
        if (root->node_type == TREE_NIL) {
            printf("\tret\n");
        } else {
            burm_reduce(root, 1);
        }
        printf("\t.cfi_endproc\n");
        printf("\t.size %s, .-%s\n", fn_name, fn_name);
    } else {
        printf("unable to burm_label\n");
        exit(3);
    }
}

