%{
#include "asm.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include "tree.h"
#include "regmap.h"
#include <stdbool.h>
#include "symtab.h"

struct CodeGenContext {
    char *fn_name;
    bool regs[REG_COUNT];
    struct regmap *var_to_reg;
    int params_count;
};

static struct CodeGenContext ctx;

enum Register reg() {
    for (int i = 0; i < REG_COUNT; ++i) {
        if (!ctx.regs[i]) {
            ctx.regs[i] = true;
            return i;
        }
    }
    printf("out of registers\n");
    exit(1);
}

void return__RETURN_numreg(struct Tree *node) {
    node->reg = LEFT_CHILD(node)->reg;
    asm_tag_number(node->reg);
    asm_move_reg_reg(node->reg, RAX);
    asm_return();
}

void return__RETURN_lstreg(struct Tree *node) {
    node->reg = LEFT_CHILD(node)->reg;
    asm_tag_list(node->reg);
    asm_move_reg_reg(node->reg, RAX);
    asm_return();
}

void numreg__NOT_numreg(struct Tree *node) {
    node->reg = LEFT_CHILD(node)->reg;
    asm_xor1(node->reg);
}

void reg__VAR(struct Tree *node) {
    struct RegInfo reg_info = regmap_lookup(ctx.var_to_reg, node->id);
    node->reg = reg();
    asm_move_reg_reg(reg_info.reg, node->reg);
}

/* symbols below must also be defined
   definition in tree.h!!!
*/
%}
%term CONST=1
%term VAR=2
%term ADDITION=3
%term SUBTRACTION=4
%term MULTIPLICATION=5
%term CONS=6
%term NOT_LESS=7
%term EQUAL=8
%term OR=9
%term NOT=10
%term ISLIST=11
%term HEAD=12
%term TAIL=13
%term STATS=14
%term RETURN=15
%term EXPR=16
%term NIL=17

%start stats
%%
stats: nil                 # 0 # printf("\tret\n");
stats: STATS(return,nil)   # 1 #
return: RETURN(reg)        # 1 # asm_return(bnode);
return: RETURN(numreg)     # 1 # return__RETURN_numreg(bnode);
return: RETURN(lstreg)     # 1 # return__RETURN_lstreg(bnode);
numreg: NOT(numreg)        # 1 # numreg__NOT_numreg(bnode);
numreg: reg                # 1 # asm_untag_number(bnode->reg);
lstreg: reg                # 1 # asm_untag_list(bnode->reg);
reg: CONST                 # 1 # asm_immediate(bnode->num, (bnode->reg = reg()));
reg: VAR                   # 1 # reg__VAR(bnode);
nil: NIL                   # 0 # ;
%%

void burm_reduce(NODEPTR_TYPE bnode, int goalnt);

void addParam(char *name) {
    enum Register r = reg();
    regmap_insert(ctx.var_to_reg, name, (struct RegInfo) { .reg = r });
    ++ctx.params_count;
}

void invoke_burm(NODEPTR_TYPE root, char *fn_name, struct Symtab *params) {
    ctx = (struct CodeGenContext) {
        .fn_name = fn_name,
        .var_to_reg = regmap_new(),
        .params_count = 0,
    };
    symtab_foreach_variable(params, addParam);
    if (ctx.params_count > 6) {
        printf("too many params\n");
        exit(32);
    }
    if(burm_label(root)) {
        printf("\t.global %s\n", fn_name);
        printf("\t.extern raisesig\n", fn_name);
        printf("\t.type %s, @function\n", fn_name);
        printf("%s:\n", fn_name);
        printf("\t.cfi_startproc\n");
        if (root->node_type == TREE_NIL) {
            printf("\tret\n");
        } else {
            burm_reduce(root, 1);
        }
        printf("\t.cfi_endproc\n");
        printf("\t.size %s, .-%s\n", fn_name, fn_name);
    } else {
        printf("unable to burm_label\n");
        exit(3);
    }
}

